package authentication

// set of tools for random generating payload
// generator is the base randomizer challenge
// used for second authentication factor such as pin code, one time password

import (
	"crypto/rand"
	"fmt"
	"io"

	"github.com/boomfunc/root/guard/trust"
)

// pin is simple pin code verification
type generator struct {
	length  int    // length of the pin code
	allowed []byte // chars allowed to be in generated bytes
}

// Fingerprint implements trust.Node interface
func (gen generator) Fingerprint() []byte {
	return []byte(
		fmt.Sprintf("Generator(length=%d, allowed=[%s])", gen.length, gen.allowed),
	)
}

// generate generates bytes according on generator rules (len and table of allowed chars)
func (gen generator) generate() ([]byte, error) {
	b := make([]byte, gen.length)

	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		return nil, err
	}
	for i := 0; i < len(b); i++ {
		b[i] = gen.allowed[int(b[i])%len(gen.allowed)]
	}

	return b, nil
}

// Ask creates pin code and send it to the node's channel
// implies that the node exists
func (gen generator) Ask(save trust.ArtifactHook, node trust.Node) error {
	// No one to ask
	if node == nil {
		return ErrChallengeFailed
	}

	// Phase 1. Generate random bytes according to rules
	generated, err := gen.generate()
	if err != nil {
		return err
	}

	// Phase 2. Run hook for generated random bytes (save part)
	if save == nil {
		return ErrChallengeFailed
	}

	if err := save(generated, gen, node); err != nil {
		return nil
	}

	// Phase 3. Send pin code to channel
	// c, err := node.Channel()
	// if err != nil {
	// 	return err
	// }
	//
	// if err := c.Send(pin); err != nil {
	// 	return err
	// }

	return nil
}

func (gen generator) Answer(fetch trust.ArtifactHook, node trust.Node, answer []byte) (trust.Node, error) {
	// No one to check answer for
	if node == nil {
		return nil, ErrChallengeFailed
	}

	// Phase 1. Run hook for generated random bytes (fetch part)
	if fetch == nil {
		return nil, ErrChallengeFailed
	}

	if err := fetch(answer, gen, node); err != nil {
		return nil, err
	}

	// no errors
	return node, nil
}
