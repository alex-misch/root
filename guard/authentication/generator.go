package authentication

// set of tools for random generating payload
// generator is the base randomizer challenge
// used for second authentication factor such as pin code, one time password

import (
	"bytes"
	"crypto/rand"
	"fmt"
	"io"

	"github.com/boomfunc/root/guard/trust"
)

// pin is simple pin code verification
type generator struct {
	length  int    // length of the pin code
	allowed []byte // chars allowed to be in generated bytes
}

// Fingerprint implements trust.Node interface
func (gen generator) Fingerprint() []byte {
	return []byte(
		fmt.Sprintf("Generator(length=%d, allowed=[%s])", gen.length, gen.allowed),
	)
}

// generate generates bytes according on generator rules (len and table of allowed chars)
func (gen generator) generate() ([]byte, error) {
	b := make([]byte, gen.length)

	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		return nil, err
	}
	for i := 0; i < len(b); i++ {
		b[i] = gen.allowed[int(b[i])%len(gen.allowed)]
	}

	return b, nil
}

// Ask creates pin code and send it to the node's channel
// implies that the node exists
func (gen generator) Ask(node trust.Node) error {
	// no one to ask
	if node == nil {
		return ErrChallengeFailed
	}

	// Phase 1. Generate random bytes according to rules
	_, err := gen.generate()
	if err != nil {
		return err
	}

	// Phase 2. Run hook for generated pin
	// if err := ch.save(pin); err != nil {
	// 	return nil
	// }

	// Phase 3. Send pin code to channel
	// if err := c.Send(pin); err != nil {
	// 	return nil, err
	// }

	return nil
}

func (gen generator) Answer(node trust.Node, answer []byte) (trust.Node, error) {

	if bytes.Equal(answer, []byte("1234")) {
		return node, nil
	}

	return nil, ErrChallengeFailed
}
