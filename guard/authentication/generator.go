package authentication

// set of tools for random generating payload
// generator is the base randomizer challenge
// used for second authentication factor such as pin code, one time password

import (
	"crypto/rand"
	"fmt"

	"github.com/boomfunc/root/guard/trust"
)

// generator is astract challenge based on random bytes generating
type generator struct {
	length  int    // length of the pin code
	allowed []byte // chars allowed to be in generated bytes
}

// Fingerprint implements trust.Node interface
func (ch generator) Fingerprint() []byte {
	return []byte(
		fmt.Sprintf("generator(length=%d, allowed=[%s])", ch.length, ch.allowed),
	)
}

// generate generates bytes according on generator rules (len and table of allowed chars)
func (ch generator) generate() ([]byte, error) {
	b := make([]byte, ch.length)

	if _, err := rand.Reader.Read(b); err != nil {
		return nil, err
	}
	for i := 0; i < len(b); i++ {
		b[i] = ch.allowed[int(b[i])%len(ch.allowed)]
	}

	return b, nil
}

// Ask creates pin code and send it to the node's channel
// implies that the node exists
func (ch generator) Ask(save trust.ArtifactHook, node trust.Node) error {
	// No one to ask
	if node == nil {
		return ErrChallengeFailed
	}

	// Phase 1. Generate challenge's artifact (random bytes according to rules).
	artifact, err := ch.generate()
	if err != nil {
		return err
	}

	// Phase 2. Run hook for generated artifact (save part)
	if save == nil {
		return ErrChallengeFailed
	}

	if err := save(artifact, ch, node); err != nil {
		return err
	}

	// Phase 3. Send pin code to channel
	// c, err := node.Channel()
	// if err != nil {
	// 	return err
	// }
	//
	// if err := c.Send(pin); err != nil {
	// 	return err
	// }

	return nil
}

func (ch generator) Answer(fetch trust.ArtifactHook, node trust.Node, answer []byte) (trust.Node, error) {
	// No one to check answer for
	if node == nil {
		return nil, ErrChallengeFailed
	}

	// Phase 1. Run hook for generated random bytes (fetch part)
	if fetch == nil {
		return nil, ErrChallengeFailed
	}

	if err := fetch(answer, ch, node); err != nil {
		return nil, err
	}

	// no errors
	return node, nil
}
